<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stupid Murphy</title>
  
  <subtitle>Haha~~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhangsun.site/"/>
  <updated>2018-11-25T02:10:31.917Z</updated>
  <id>http://www.zhangsun.site/</id>
  
  <author>
    <name>Murphy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis为什么快</title>
    <link href="http://www.zhangsun.site/2018/03/28/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB/"/>
    <id>http://www.zhangsun.site/2018/03/28/Redis为什么快/</id>
    <published>2018-03-28T00:28:49.000Z</published>
    <updated>2018-11-25T02:10:31.917Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Redis是一个单进程、单线程的NOSQL数据库，但是官方却声称，Redis可以实现100000+的QPS，实践证明确实可以达到如此快的速度。那么一个单线程单进程的数据库是如何实现如此快的查询呢？</p><h3 id="Redis快的原因"><a href="#Redis快的原因" class="headerlink" title="Redis快的原因"></a>Redis快的原因</h3><ul><li>Redis是一个基于内存的数据库<br>大家都知道内存的读写数据速度是非常快的，那么实际上到底有多快呢？小编也没有测过，从互联网上抄来一组数据来说明一下问题：<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fps8z90i89j30hs09i3z6.jpg" alt=""></li><li>Redis采用的是Key/Value形式的存储结构<br>Key/Value形式的数据形式在读取和写入的时候都比较简单，能进行快速的查询。</li><li>Redis采用了多IO复用机制</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Redis是一个单进程、单线程的NOSQL数据库，但是官方却声称，Redis可以实现100000+的QPS，实践证明确实可以达到如此快的速度
      
    
    </summary>
    
      <category term="Technology" scheme="http://www.zhangsun.site/categories/Technology/"/>
    
    
      <category term="Redis" scheme="http://www.zhangsun.site/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java面试知识点总结</title>
    <link href="http://www.zhangsun.site/2018/02/01/Java%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://www.zhangsun.site/2018/02/01/Java面试知识点总结/</id>
    <published>2018-02-01T06:22:30.000Z</published>
    <updated>2018-02-24T07:16:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h3><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p><a href="http://www.cnblogs.com/wang-meng/p/5701918.html" target="_blank" rel="noopener">java基础面试</a></p><h3 id="前台框架"><a href="#前台框架" class="headerlink" title="前台框架"></a>前台框架</h3><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><ol><li><p><strong>闭包</strong></p><p> 闭包是JavaScript中的一种语法现象，指的是在函数的内部定义了子函数，并且子函数访问了父函数中的成员变量。定义一个闭包现象如下：</p><pre><code>fout = function(){    var v1 = 10;    fin = function(){        var v2 = v1;        return v2;    }    return fin;}var out = fout() //  fin()var in = out() //  10</code></pre><p> 通过闭包中的子函数可以访问到父函数中的成员变量但是外部的父函数却不能访问子函数中的成员变量，这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p> 既然fin可以读取fout中的局部变量，那么只要把fin作为返回值，我们不就可以在fout外部读取它的内部变量了吗！</p></li></ol><ol start="2"><li><p><strong>JavaScript 中 undefined 和 not defined 的区别:</strong><br>undefined是javaScript中的一种原始数据类型，表示没有初始化的变量或者函数的初始化值。如果一个变量或者函数只定义了，而没有初始化，则用typeof会返回一个undefined。</p><pre><code>var val;alert(typeof val) // undefined</code></pre><p>not defined是一种错误提示消息，表示变量没有定义过就使用了，如下：</p><pre><code>var val = x; // x会报错: Unresolved variable or type x</code></pre></li><li><p><strong>全局对象</strong><br> JavaScript的全局对象是指，该语言中的内置对象，这些对象可以在javaScript代码的任何位置不用声明就可以直接使用，类似Java中的基本类型数据。<br> 常用到的全局对象有：</p><pre><code>eval(String)：接受一个字符串参数，用于执行字符串代码。typeof： 返回一个变量的数据类型。Number() ：把对象的值转换为数字。String()： 把对象的值转换为字串。parseInt(String)：解析一个字符串并返回一个整数。parseFloat(String)：解析一个字符串并返回一个浮点数。decodeURI()：解码某个编码的 URI。decodeURIComponent()：解码一个编码的 URI 组件。encodeURI()：把字符串编码为 URI。</code></pre><p> 下面面试题输出的结果是甚末？</p><pre><code>var y = 1;if (function f(){}) {    y += typeof f;}console.log(y);</code></pre><p> 输出结果：1undefined</p></li><li><p><strong>怎么判断一个object是否是数组(array)？</strong></p><pre><code>object.__proto__ === Array.prototype; // 利用原型链$.isArray(object) // 利用jQuery</code></pre></li><li><p><strong>JavaScript怎么清空数组？</strong></p><pre><code>var arr = [1, 2, 3, 4, 5];arr = []; // 方法一arr.length = 0; // 方法二 </code></pre></li><li><p><strong>JavaScript中自执行匿名函数</strong>    </p><p> 自执行匿名函数定义：<br> 常见格式：(function() { /<em> code </em>/ })();<br> 解释：包围函数（function(){})的第一对括号向脚本返回未命名的函数，随后一对空括号立即执行返回的未命名函数，括号内为匿名函数的参数。<br> 作用：可以用它创建命名空间，只要把自己所有的代码都写在这个特殊的函数包装内，那么外部就不能访问，除非你允许(变量前加上window，这样该函数或变量就成为全局)。各JavaScript库的代码也基本是这种组织形式。</p><p> 总结一下，执行函数的作用主要为 匿名 和 自动执行,代码在被解释时就已经在运行了。</p><p> 下面代码输出的结果是甚末？</p><pre><code>var output = (function(x){    delete x;    return x;})(0);console.log(output);</code></pre><p>输出是 0。 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete" target="_blank" rel="noopener">delete</a> 操作符是将object的属性删去的操作。但是这里的 x 是并不是对象的属性， delete 操作符并不能作用。</p></li><li><p><strong>什么是 undefined x 1 ？</strong><br> 在chrome下执行如下代码，我们就可以看到undefined x 1的身影。</p><pre><code>var trees = [&quot;redwood&quot;,&quot;bay&quot;,&quot;cedar&quot;,&quot;oak&quot;,&quot;maple&quot;];delete trees[3];console.log(trees);</code></pre><p> 当我们使用 delete 操作符删除一个数组中的元素，这个元素的位置就会变成一个占位符。打印出来就是undefined x 1。<br> 注意如果我们使用trees[3] === ‘undefined × 1’返回的是 false。因为它仅仅是一种打印表示，并不是值变为undefined x 1。</p></li><li><p><strong>下面代码输出什么？</strong></p><pre><code>var bar = true;console.log(bar + 0);   console.log(bar + &quot;xyz&quot;);  console.log(bar + true);  console.log(bar + false);   </code></pre><p> 输出是:<br> 1<br> truexyz<br> 2<br> 1</p><p> 下面给出一个加法操作表:<br> Number + Number -&gt; 加法<br> Boolean + Number -&gt; 加法<br> Boolean + Boolean -&gt; 加法<br> Number + String -&gt; 连接<br> String + Boolean -&gt; 连接<br> String + String -&gt; 连接</p></li><li><p><strong>两种函数声明有什么区别？</strong></p><pre><code>var foo = function(){     // Some code}; function bar(){     // Some code}; </code></pre><p> 第一种函数定义是在运行时；第二种定义实在解析时，存在变量提升。看看如下代码的运行结果：</p><pre><code>console.log(foo)console.log(bar)var foo = function(){     // Some code}; function bar(){     // Some code}; </code></pre><p> 结果是：</p><pre><code>undefinedfunction bar(){     // Some code};</code></pre><p> 第二种方式JavaScript在执行时，会将变量提升。</p></li><li><p><a href="http://www.runoob.com/js/js-hoisting.html" target="_blank" rel="noopener"><strong>JavaScript 变量提升</strong></a><br>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。<br>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p></li><li><p><strong>内存泄漏</strong><br>内存泄露是指变量使用完之后没有被销毁，一直常驻内存，无法被垃圾回收器回收导致的内存浪费，严重的时候会导致内存溢出。引发内存泄露的原因通常是因为不规范编码造成的。一般有一下几种现象：<br>全局变量引起的内存泄漏：</p><pre><code>function leaks(){      leak = 11; // leak 成为一个全局变量，方法执行完成之后，不会被回收}</code></pre><p>闭包引起的内存泄漏：</p><pre><code>function leaks(){    let leak = 11; // 被闭包所引用，不会被回收    function fin() {        console.log(leak);     }    return fin();}</code></pre><p>事件未清除导致的内存泄漏</p></li></ol><h4 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h4><ol><li><p><strong>Ajax</strong><br> 简述ajax 的过程。</p><ul><li>创建XMLHttpRequest对象,也就是创建一个异步调用对象</li><li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</li><li>设置响应HTTP请求状态变化的函数</li><li>发送HTTP请求</li><li>获取异步调用返回的数据</li><li>使用JavaScript和DOM实现局部刷新</li></ul></li></ol><p>同步和异步的区别?<br>syn<br>如何解决跨域问题?</p><p>JavaScript 的同源策略</p><pre><code>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。</code></pre><p>解释jsonp的原理，以及为什么不是真正的ajax</p><pre><code>Jsonp并不是一种数据格式，而json是一种数据格式，jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术</code></pre><h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><ol><li><p><strong>简介</strong></p><p> React是Facebook2013年开源的一个JavaScript项目，是用来构建UI界面的，相当于MVC模型中View层。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。</p></li><li><p><strong>React主要的原理</strong></p><p> 传统的web应用，操作DOM一般是直接更新操作的，但是我们知道DOM更新通常是比较昂贵的。而React为了尽可能减少对DOM的操作，提供了一种不同的而又强大的方式来更新DOM，代替直接的DOM操作。就是Virtual DOM,一个轻量级的虚拟的DOM，就是React抽象出来的一个对象，描述dom应该什么样子的，应该如何呈现。通过这个Virtual DOM去更新真实的DOM，由这个Virtual DOM管理真实DOM的更新。</p><p> 为什么通过这多一层的Virtual DOM操作就能更快呢？ 这是因为React有个diff算法，更新Virtual DOM并不保证马上影响真实的DOM，React会等到事件循环结束，然后利用这个diff算法，通过当前新的dom表述与之前的作比较，计算出最小的步骤更新真实的DOM。</p></li><li><p><strong>特点：</strong></p><ul><li>不直接操作DOM对象，而是通过虚拟DOM通过diff算法以最小的步骤作用到真实的DOM上；</li><li>组件化开发，代码的复用性高；</li><li>异步更新页面，不用刷新整个页面；</li></ul></li><li><p><strong>state, props, refs, keys的作用：</strong></p><ul><li><p>state: 是React中组件的一个对象。React把用户界面当做是状态机，想象它有不同的状态然后渲染这些状态,可以轻松让用户界面与数据保持一致。 React中,更新组件的state,会导致重新渲染用户界面(不要操作DOM).简单来说,就是用户界面会随着state变化而变化。调用setState(data,callback)这个方法会合并、更新data到this.state，并重新渲染组件。渲染完成后，调用可选的callback回调。大部分情况不需要提供callback，因为React会负责吧界面更新到最新状态。</p></li><li><p>props: 用来从父级组件向子集组件传递参数的容器。React 里，数据通过props 从拥有者流向归属者。</p></li><li><p>ref: 是React中的一个特殊属性，这个属性用在render()方法返回的组件上，用来标记组件，以便于获取到该组件的实例。<br>ref的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&quot;myInput&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>   要想访问这个实例，可以通过this.refs来访问：       this.refs.myInput- key: 它是一个特殊的属性，它是出现不是给开发者用的（例如你为一个组件设置key之后不能获取组件的这个key props），而是给react自己用的。react利用key来识别组件，它是一种身份标识标识，就像我们的身份证用来辨识一个人一样。每个key对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。key值的唯一是有范围的，即在数组生成的同级同类型的组件上要保持唯一，而不是所有组件的key都要保持唯一。不仅仅在数组生成组件上，其他地方也可以使用key，主要是react利用key来区分组件的，相同的key表示同一个组件，react不会重新销毁创建组件实例，只可能更新；key不同，react会销毁已有的组件实例，重新创建组件新的实例。</code></pre><ol start="5"><li><p><strong>定义一个组件：</strong></p><pre><code>import React from &quot;react&quot;;import {Row,Col} from &quot;antd&quot;;import &quot;antd/dist/antd.css&quot;;export default class PCFooter extends React.Component{    render(){        return(            &lt;footer className={&quot;footer&quot;}&gt;            &lt;Row&gt;                &lt;Col span={2}&gt;&lt;/Col&gt;                &lt;Col span={20}&gt;                &lt;p&gt;&amp;copy;&amp;nbsp;2017-2050 ReactNews CopyRight Reserved.&lt;/p&gt;                &lt;/Col&gt;                &lt;Col span={2}&gt;&lt;/Col&gt;            &lt;/Row&gt;            &lt;/footer&gt;        );    };}</code></pre></li><li><p><strong>AntD</strong><br> Ant Design是蚂蚁金服开发的一款前端UI框架，可以帮助开发者快速搭建漂亮的页面，即使你是一个不懂设计的开发者，也能快速地写出比较好看的前端页面。从而提高了页面的开发效率。与React结合开发前端页面效果不错。</p></li><li><p><strong>开发流程</strong></p><ul><li>导入需要的模块；</li><li>定义一个组件，继承React.Component，用到关键字export, default, class, extends</li><li>编写构造器（可选，用于初始化参数）;</li><li>编写render()方法，用于渲染组件；</li><li>编写render()方法中的return()方法，返回组件；</li><li>在其他组件中导入编写的组件，用props进行参数传递。</li></ul></li><li><p><strong>NodeJS</strong></p><p> 简单的说 Node.js 就是运行在服务端的 JavaScript。自从前后端开发分离之后，前端代码从后段代码中剥离出来了，搭建独立的前端服务器，Node.JS就是前端项目服务器, 类似Tomcat、Apache、Nginx。<br> Node.Js采用NPM对前端项目中的依赖JS包进行管理，在新版本中NPM已经包含在了Node.js中，用户只需要安装Node即可，不需要额外安装NPM。</p><p> 接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。</p></li></ol><p>实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：</p><pre><code>var http = require(&apos;http&apos;);http.createServer(function (request, response) {    // 发送 HTTP 头部     // HTTP 状态值: 200 : OK    // 内容类型: text/plain    response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});    // 发送响应数据 &quot;Hello World&quot;    response.end(&apos;Hello World\n&apos;);}).listen(8888);// 终端打印如下信息console.log(&apos;Server running at http://127.0.0.1:8888/&apos;);以上代码我们完成了一个可以工作的 HTTP 服务器。使用 node 命令执行以上的代码：node server.jsServer running at http://127.0.0.1:8888/</code></pre><ol start="9"><li><p><strong>NPM</strong></p><ul><li>npm init：会引导你创建一个package.json文件，包括名称、版本、作者这些信息等</li><li>npm install moduleNames：安装Node模块</li><li>npm install <name> -g： 将包安装到全局环境中</name></li><li>npm install <name> –save： 安装的同时，将信息写入package.json中项目路径中（如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包，这样代码提交到github时，就不用提交node_modules这个文件夹了）。</name></li><li>npm uninstall moudleName：卸载node模块</li><li>npm update moduleName：更新node模块</li><li>npm list：查看当前目录下已安装的node包</li><li>npm -v：查看npm安装的版本</li></ul></li></ol><h3 id="后台框架"><a href="#后台框架" class="headerlink" title="后台框架"></a>后台框架</h3><h4 id="SpringMvc"><a href="#SpringMvc" class="headerlink" title="SpringMvc"></a>SpringMvc</h4><ol><li><p>SpringMVC的工作流程？</p><ul><li>客户端发起请求到DispatcherServlet(前端控制器)；</li><li><p>调用HandlerMapping(处理器映射器)，根据请求中的url到xml配置或注解(@RequestMapping)中去进行查找对应的Handler(处理器)；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;/url&quot; class=&quot;com.example.controller.Controller&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>HandlerMapping 生成HandlerIntercepter(处理器拦截器)，将其和Handler一并返回给前端控制器；</p></li></ul></li><li><p>SpringMVC和Struts2的区别：</p></li><li><h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><h4 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h4><h4 id="Struts2"><a href="#Struts2" class="headerlink" title="Struts2"></a>Struts2</h4><h4 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h4><h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h4></li></ol><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><h4 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h4><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><ol><li>简介</li><li>Http服务器</li><li>负载均衡服务器<br><a href="http://www.cnblogs.com/wang-meng/p/5861174.html#3896182" target="_blank" rel="noopener">Nginx负载均衡的详细配置及使用案例详解.</a></li><li>反向代理服务器</li></ol><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><ol><li><strong>Sql优化</strong></li><li><strong>锁</strong><br> 死锁<br> 锁策略<br> 锁粒度<pre><code>表级锁行级锁</code></pre></li><li><strong>事务</strong><br> 原子性<br> 一致性<br> 持久性<br> 隔离性<pre><code>脏读不可重复读虚度/幻读序列化</code></pre><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4></li><li><strong>数据类型</strong><br>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</li><li><p><strong>Jedis</strong></p></li><li><p><strong>Redis与</strong></p></li><li><p><strong>Redis的应用场景</strong></p><ul><li>缓存<br>  Redis读写速度每秒在10万次左右，可以对查询频繁的数据进行缓存，能实现高效的查询。</li><li>技术器<br>  使用INCREABY和DECREABY可以实现计数器</li><li>分布式锁与单线程<br>  Redis是单线程的所以可以控制多线程并发访问资源的问题</li><li>计时器<br>  Redis新版本推出了key过期事件，可以通过订阅指定的key事件来实现定时任务，但这是新版本的特性。<h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4></li></ul></li><li><strong>数据类型</strong></li><li><strong>JavaAPI</strong><h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><h4 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h4>Dubbo是阿里开源的一款微服务框架，可以与Spring整合实现分布式应用之间服务的管理。<br>Dubbo四个组件组成：</li></ol><ul><li>生产者：服务的提供者；</li><li>消费者：服务的订阅者；</li><li>注册中心：用于服务的发布和订阅；<br>  通常使用Zookeeper作为注册中心，因为Zookeeper可以通过节点进行订阅和发布数据。</li><li>监控中心：用于服务的监控和管理。<h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4></li></ul><h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><pre><code>- Zookeeper最初时应用在大数据中的，被用于分布式系统中用于维护分布式应用配置的一致性。- 作为Dubbo的注册中心- 作为项目的配置中心首先动态加载相关bean，如果配置中心发生改变，对应的watcher监听到事件后，客户端则对相关bean进行重新注册，并且从配置中心获取到了最新数据，然后客户端直接调用getBean()方法获取相关bean实例，确保不再是之前引用。</code></pre><h4 id="Freemarker"><a href="#Freemarker" class="headerlink" title="Freemarker"></a>Freemarker</h4><h4 id="SwaggerAPI"><a href="#SwaggerAPI" class="headerlink" title="SwaggerAPI"></a>SwaggerAPI</h4><h4 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h4><h4 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h4><h4 id="定时任务框架"><a href="#定时任务框架" class="headerlink" title="定时任务框架"></a>定时任务框架</h4><ol><li><strong>JDK</strong></li><li><strong>Spring-Task</strong></li><li><strong>Quartz</strong></li><li><a href="http://blog.csdn.net/fanfan_v5/article/details/61310045" target="_blank" rel="noopener"><strong>Elestic Job</strong></a></li><li><strong>Zookeeper</strong></li></ol><h4 id="WebService（CXF）"><a href="#WebService（CXF）" class="headerlink" title="WebService（CXF）"></a>WebService（CXF）</h4><h4 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h4><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><h4 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h4><h4 id="PostMan"><a href="#PostMan" class="headerlink" title="PostMan"></a>PostMan</h4><h4 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h4><h4 id="Datagrid"><a href="#Datagrid" class="headerlink" title="Datagrid"></a>Datagrid</h4><h4 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h4><h4 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h4><h3 id="加分项"><a href="#加分项" class="headerlink" title="加分项"></a>加分项</h3><h4 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h4><ul><li>防止空指针</li><li>Kotlin文件类型有class, object, menu, interface</li><li>伴生对象对应java中的static</li><li>但例采用object </li><li>高阶函数</li><li>Lambda表达式</li><li>详见博客《Kotlin基础语法》<h4 id="Vertx"><a href="#Vertx" class="headerlink" title="Vertx"></a>Vertx</h4></li><li>EvenBus异步执行，提高执行效率</li><li>使用多层嵌套解决同步问题</li><li>使用标签跳出指定层<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;JavaSE&quot;&gt;&lt;a href=&quot;#JavaSE&quot; class=&quot;headerlink&quot; title=&quot;JavaSE&quot;&gt;&lt;/a&gt;JavaSE&lt;/h3&gt;&lt;h4 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="面试" scheme="http://www.zhangsun.site/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门</title>
    <link href="http://www.zhangsun.site/2018/01/31/SpringBoot%E5%85%A5%E9%97%A8/"/>
    <id>http://www.zhangsun.site/2018/01/31/SpringBoot入门/</id>
    <published>2018-01-31T08:35:01.000Z</published>
    <updated>2018-01-31T08:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="认识springboot"><a href="#认识springboot" class="headerlink" title="认识springboot"></a>认识springboot</h4><p><strong>Springboot的发展趋势</strong></p><p>Springboot是spring的增强版,是下一代的框架<br><img src="SpringBoot入门/1.png" alt="SpringBoot"></p><h4 id="搭建springboot的入门程序"><a href="#搭建springboot的入门程序" class="headerlink" title="搭建springboot的入门程序"></a>搭建springboot的入门程序</h4><p><strong>创建工程</strong><br><img src="SpringBoot入门/2.png" alt="SpringBoot"><br><img src="SpringBoot入门/3.png" alt="SpringBoot"><br>Springboot版本号<br><img src="SpringBoot入门/4.png" alt="SpringBoot"><br>项目存储路径<br><img src="SpringBoot入门/5.png" alt="SpringBoot"><br>删除三个文件<br><img src="SpringBoot入门/6.png" alt="SpringBoot"><br>Pom文件中的springboot的依赖<br><img src="SpringBoot入门/7.png" alt="SpringBoot"><br>右键点击运行<br><img src="SpringBoot入门/8.png" alt="SpringBoot"><br>编写一个入门程序<br><img src="SpringBoot入门/9.png" alt="SpringBoot"><br>启动程序访问浏览器<br><img src="SpringBoot入门/10.png" alt="SpringBoot"></p><h4 id="第一种项目的配置文件application-properties"><a href="#第一种项目的配置文件application-properties" class="headerlink" title="第一种项目的配置文件application.properties"></a>第一种项目的配置文件application.properties</h4><p><img src="SpringBoot入门/11.png" alt="SpringBoot"><br><strong>配置文件的配置说明</strong></p><p>springBoot项目默认端口号是8080,配置端口号:<br><img src="SpringBoot入门/12.png" alt="SpringBoot"><br>启动访问浏览器<br><img src="SpringBoot入门/13.png" alt="SpringBoot"></p><h4 id="第二种项目配置文件的方式yml的方式"><a href="#第二种项目配置文件的方式yml的方式" class="headerlink" title="第二种项目配置文件的方式yml的方式"></a>第二种项目配置文件的方式yml的方式</h4><p><img src="SpringBoot入门/14.png" alt="SpringBoot"><br>浏览器访问<br><img src="SpringBoot入门/15.png" alt="SpringBoot"><br><img src="SpringBoot入门/16.png" alt="SpringBoot"></p><h4 id="配置多个路径映射"><a href="#配置多个路径映射" class="headerlink" title="配置多个路径映射"></a>配置多个路径映射</h4><p><img src="SpringBoot入门/17.png" alt="SpringBoot"></p><h4 id="当使用rest风格的请求路径的时候获取请求参数"><a href="#当使用rest风格的请求路径的时候获取请求参数" class="headerlink" title="当使用rest风格的请求路径的时候获取请求参数"></a>当使用rest风格的请求路径的时候获取请求参数</h4><p><img src="SpringBoot入门/18.png" alt="SpringBoot"><br><img src="SpringBoot入门/19.png" alt="SpringBoot"></p><h4 id="当时用传统请求时获取请求参数"><a href="#当时用传统请求时获取请求参数" class="headerlink" title="当时用传统请求时获取请求参数"></a>当时用传统请求时获取请求参数</h4><p><img src="SpringBoot入门/20.png" alt="SpringBoot"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;认识springboot&quot;&gt;&lt;a href=&quot;#认识springboot&quot; class=&quot;headerlink&quot; title=&quot;认识springboot&quot;&gt;&lt;/a&gt;认识springboot&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Springboot的发展趋势&lt;/stron
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://www.zhangsun.site/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>支付宝支付功能</title>
    <link href="http://www.zhangsun.site/2018/01/31/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD/"/>
    <id>http://www.zhangsun.site/2018/01/31/支付宝支付功能/</id>
    <published>2018-01-31T08:32:39.000Z</published>
    <updated>2018-01-31T08:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="支付宝支付功能/1.png" alt="JavaEE"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;支付宝支付功能/1.png&quot; alt=&quot;JavaEE&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JavaEE" scheme="http://www.zhangsun.site/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>List集合切割的工具类</title>
    <link href="http://www.zhangsun.site/2018/01/31/List%E9%9B%86%E5%90%88%E5%88%87%E5%89%B2%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://www.zhangsun.site/2018/01/31/List集合切割的工具类/</id>
    <published>2018-01-31T08:05:53.000Z</published>
    <updated>2018-01-31T08:07:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="List集合切割的工具类"><a href="#List集合切割的工具类" class="headerlink" title="List集合切割的工具类"></a>List集合切割的工具类</h4><p><strong>问题背景:</strong></p><p>我们在处理List集合的时候难免会遇到集合的size比较大,这时候我们就需要将一个比较大的list集合拆分成几个size比较小的集合进型处理,这样操作主要是考虑到了性能的问题,所以以下的工具类是针对于一个大的List集合进行拆分的过程</p><p><strong>代码实现:</strong></p><pre><code>/** * 切割List集合,将其分成等分的 *  * @param source * @param pageSize * @return */public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; splitList(List&lt;T&gt; source, Integer pageSize) {    if (null == source || source.size() == 0) {        return null;    }    int size = source.size();    int num = size / pageSize + 1;    // 切割list集合    List&lt;List&lt;T&gt;&gt; target = new ArrayList&lt;List&lt;T&gt;&gt;();    List&lt;T&gt; subList = null;    for (int i = 0; i &lt; num; i++) {        int from = i * pageSize;        //如果不是最后一个集合        if (i != num - 1) {            subList = source.subList(from, from + pageSize);        } else {            subList = source.subList(from, from + size % pageSize);        }        target.add(subList);    }    return target;}</code></pre><p>}<br><strong>代码理解</strong></p><p>num:表示大集合将要被切割的个数<br>pageSize表示每个小集合的size<br>subList = source.subList(from, from + pageSize);如果不是最后一个集合,我们需要切割from 到from + pageSize个<br>subList = source.subList(from, from + size % pageSize); 如果切割刀最后一个集合的时候,我们需要从from切割到from + size的余数(size % pageSize)</p><p>功能测试</p><pre><code>public static void main(String[] args) {    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();    list.add(1);    list.add(2);    list.add(3);    list.add(4);    list.add(5);    list.add(5);    list.add(6);    List&lt;List&lt;Integer&gt;&gt; splitList = splitList(list, 2);    System.out.println(splitList);}</code></pre><p>测试运行结果<br>[[1, 2], [3, 4], [5, 5], [6]]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;List集合切割的工具类&quot;&gt;&lt;a href=&quot;#List集合切割的工具类&quot; class=&quot;headerlink&quot; title=&quot;List集合切割的工具类&quot;&gt;&lt;/a&gt;List集合切割的工具类&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;问题背景:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Utilities" scheme="http://www.zhangsun.site/tags/Utilities/"/>
    
  </entry>
  
  <entry>
    <title>MySql数据库的事务</title>
    <link href="http://www.zhangsun.site/2018/01/31/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1/"/>
    <id>http://www.zhangsun.site/2018/01/31/MySql数据库的事务/</id>
    <published>2018-01-31T07:20:20.000Z</published>
    <updated>2018-02-09T08:21:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="事务的四大特性："><a href="#事务的四大特性：" class="headerlink" title="事务的四大特性："></a>事务的四大特性：</h4><p><strong>原子性：</strong>共同成败<br><strong>一致性：</strong>事务前后数据不会损坏，保持原有的完整性<br><strong>隔离性：</strong>事务之间互不干扰<br><strong>持久性：</strong>一旦事务提交，数据就永远的保存到了数据库中</p><p>不考虑事务的隔离性会发生：脏读，不可重复读，虚读幻读</p><p>解决上述问题的方式是：设置数据库的隔离级别</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;事务的四大特性：&quot;&gt;&lt;a href=&quot;#事务的四大特性：&quot; class=&quot;headerlink&quot; title=&quot;事务的四大特性：&quot;&gt;&lt;/a&gt;事务的四大特性：&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;原子性：&lt;/strong&gt;共同成败&lt;br&gt;&lt;strong&gt;一致性：&lt;/str
      
    
    </summary>
    
    
      <category term="MySql" scheme="http://www.zhangsun.site/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="http://www.zhangsun.site/2018/01/31/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.zhangsun.site/2018/01/31/Java多线程/</id>
    <published>2018-01-31T06:57:54.000Z</published>
    <updated>2018-01-31T07:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程与线程的概念理解"><a href="#进程与线程的概念理解" class="headerlink" title="进程与线程的概念理解:"></a>进程与线程的概念理解:</h4><pre><code>进程:执行的应用程序.线程:程序执行的一条路径</code></pre><h4 id="线程的生命周期以及五中状态"><a href="#线程的生命周期以及五中状态" class="headerlink" title="线程的生命周期以及五中状态"></a>线程的生命周期以及五中状态</h4><p><img src="Java多线程/1.png" alt="javaSE"></p><h4 id="Java线程具有五中基本状态"><a href="#Java线程具有五中基本状态" class="headerlink" title="Java线程具有五中基本状态"></a>Java线程具有五中基本状态</h4><p><strong>新建状态（New）</strong>：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</p><p><strong>就绪状态（Runnable）</strong>：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p><p><strong>运行状态（Running）</strong>：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就     绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p><p><strong>阻塞状态（Blocked）</strong>：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p><pre><code>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；2.同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；3.其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</code></pre><p><strong>死亡状态（Dead）</strong>：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p><h4 id="java中线程创建的几种形式"><a href="#java中线程创建的几种形式" class="headerlink" title="java中线程创建的几种形式"></a>java中线程创建的几种形式</h4><p>1.继承Thread类,重写run方法</p><pre><code> class MyThread extends Thread {      private int i = 0;      @Override      public void run() {      for (i = 0; i &lt; 100; i++) {          System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);     }     } }public class ThreadTest {    public static void main(String[] args) {    for (int i = 0; i &lt; 100; i++) {        System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);        if (i == 30) {            Thread myThread1 = new MyThread();     // 创建一个新的线程  myThread1  此线程进入新建状态            Thread myThread2 = new MyThread();     // 创建一个新的线程 myThread2 此线程进入新建状态            myThread1.start();                     // 调用start()方法使得线程进入就绪状态            myThread2.start();                     // 调用start()方法使得线程进入就绪状态        }    }    }}</code></pre><p>2.实现runnable接口,重写run方法</p><pre><code>class MyRunnable implements Runnable {    private int i = 0;    @Override    public void run() {    for (i = 0; i &lt; 100; i++) {        System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);    }    }}public class ThreadTest {    public static void main(String[] args) {    for (int i = 0; i &lt; 100; i++) {        System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);        if (i == 30) {            Runnable myRunnable = new MyRunnable(); // 创建一个Runnable实现类的对象            Thread thread1 = new Thread(myRunnable); // 将myRunnable作为Thread target创建新的线程            Thread thread2 = new Thread(myRunnable);            thread1.start(); // 调用start()方法使得线程进入就绪状态            thread2.start();        }    }    }}</code></pre><p>理解ThreadLocal:<br>ThreadLocal叫做 线程局部变量,<br>1、每个线程都有自己的局部变量</p><pre><code>每个线程都有一个独立于其他线程的上下文来保存这个变量，一个线程的本地变量对其他线程是不可见的（有前提，后面解释）</code></pre><p>2、独立于变量的初始化副本</p><pre><code>ThreadLocal可以给一个初始值，而每个线程都会获得这个初始化值的一个副本，这样才能保证不同的线程都有一份拷贝。</code></pre><p>3、状态与某一个线程相关联<br>    ThreadLocal 不是用于解决共享变量的问题的，不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制，理解这点对正确使用ThreadLocal至关重要。</p><p>ThreadLocal实现机制</p><pre><code>/**1、每个Thread对象内部都维护了一个ThreadLocalMap这样一个ThreadLocal的Map，可以存放若干个ThreadLocal。ThreadLocal.ThreadLocalMap threadLocals = null;2、当我们在调用get()方法的时候，先获取当前线程，然后获取到当前线程的ThreadLocalMap对象，如果非空，那么取出ThreadLocal的value，否则进行初始化，初始化就是将initialValue的值set到ThreadLocal中。**/public T get() {    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null) {    ThreadLocalMap.Entry e = map.getEntry(this);    if (e != null)        return (T)e.value;    }    return setInitialValue();}</code></pre><p>　事实上，从本质来讲，就是每个线程都维护了一个map，而这个map的key就是threadLocal，而值就是我们set的那个值，每次线程在get的时候，都从自己的变量中取值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;进程与线程的概念理解&quot;&gt;&lt;a href=&quot;#进程与线程的概念理解&quot; class=&quot;headerlink&quot; title=&quot;进程与线程的概念理解:&quot;&gt;&lt;/a&gt;进程与线程的概念理解:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;进程:执行的应用程序.
线程:程序执行的一条路径
&lt;/c
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="http://www.zhangsun.site/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JS基础知识点</title>
    <link href="http://www.zhangsun.site/2018/01/31/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://www.zhangsun.site/2018/01/31/JS基础知识点/</id>
    <published>2018-01-31T01:05:37.000Z</published>
    <updated>2018-01-31T05:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是JS中的闭包"><a href="#什么是JS中的闭包" class="headerlink" title="什么是JS中的闭包"></a>什么是JS中的闭包</h4><p>闭包就是能够读取其他函数内部变量的函数</p><pre><code>function foo(x) {    var tmp = 3;    return function (y) {    alert(x + y + (++tmp));    }}var bar = foo(2); // bar 现在是一个闭包bar(10);</code></pre><p>&emsp;&emsp;由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数</p><h4 id="JS的数据类型"><a href="#JS的数据类型" class="headerlink" title="JS的数据类型"></a>JS的数据类型</h4><pre><code>1.基本数据类型:String,Boolean,Number,Undefined, NULL2.引用数据类型:Object(Array,Date,RegExp,Function)</code></pre><h4 id="获取页面中所有的input"><a href="#获取页面中所有的input" class="headerlink" title="获取页面中所有的input"></a>获取页面中所有的input</h4><pre><code>var domList = document.getElementsByTagName(‘input’)</code></pre><h4 id="什么是Ajax和JSON，它们的优缺点"><a href="#什么是Ajax和JSON，它们的优缺点" class="headerlink" title="什么是Ajax和JSON，它们的优缺点"></a>什么是Ajax和JSON，它们的优缺点</h4><pre><code>Ajax是异步的Javascript和XML,用于WEB页面中异步数据交互优点:    1.使得用户在不刷新页面的情况下加载数据,提高用户的体验性    2.在不重载页面的情况下加载局部数据,减少数据的交互量  缺点:    1.存在安全问题    2.对搜索引擎支持不好    3.一些手持设备目前还不支持  </code></pre><p> Json是一个轻量级的数据交互格式,ECMA的一个子集,所以js支持性好</p><pre><code>优点:    1.轻量级,易于人编写和阅读    2.是ECMA的一个子集,和js结合好,便于解析</code></pre><h4 id="什么是eval-函数"><a href="#什么是eval-函数" class="headerlink" title="什么是eval()函数"></a>什么是eval()函数</h4><p>此函数是将json格式的字符串转换成JavaScript对象</p><h4 id="JS遍历Json数据"><a href="#JS遍历Json数据" class="headerlink" title="JS遍历Json数据"></a>JS遍历Json数据</h4><pre><code>var data=[{name:&quot;a&quot;,age:12},{name:&quot;b&quot;,age:11},{name:&quot;c&quot;,age:13},{name:&quot;d&quot;,age:14}];for(var o in data){    alert(o);    alert(data[o]);    alert(&quot;text:&quot;+data[o].name+&quot; value:&quot;+data[o].age );}&lt;script type=&quot;text/javascript&quot;&gt;    function text(){        var json = {&quot;options&quot;:&quot;[{/&quot;text/&quot;:/&quot;王家湾/&quot;,/&quot;value/&quot;:/&quot;9/&quot;},{/&quot;text/&quot;:/&quot;李家湾/&quot;,/&quot;value/&quot;:/&quot;10/&quot;},{/&quot;text/&quot;:/&quot;邵家湾/&quot;,/&quot;value/&quot;:/&quot;13/&quot;}]&quot;}        json = eval(json.options)        for(var i=0; i&lt;json.length; i++){            alert(json[i].text+&quot; &quot; + json[i].value)        }    }&lt;/script&gt;</code></pre><h4 id="Ajax技术原理"><a href="#Ajax技术原理" class="headerlink" title="Ajax技术原理"></a>Ajax技术原理</h4><p>&emsp;&emsp;Ajax是通过XMLHTTPRequest对象异步向服务器端发送请求,服务器端接收请求处理,返回XML或者JSON数据</p><h4 id="Ajax的执行步骤"><a href="#Ajax的执行步骤" class="headerlink" title="Ajax的执行步骤"></a>Ajax的执行步骤</h4><p>1.创建XMLHTTPRequest对象<br>2.监听 onreadystatechange事件<br>3.打开连接<br>4.发送请求</p><pre><code>function Ustbwuyi() {    var data = document.getElementById(&quot;username&quot;).value;    CreateXmlHttp();    if (!xmlhttp) {    alert(&quot;创建xmlhttp对象异常！&quot;);    return false;    }    xmlhttp.open(&quot;POST&quot;, url, false);    xmlhttp.onreadystatechange = function () {    if (xmlhttp.readyState == 4) {        document.getElementById(&quot;user1&quot;).innerHTML = &quot;数据正在加载...&quot;;        if (xmlhttp.status == 200) {            document.write(xmlhttp.responseText);        }    }    }    xmlhttp.send();}</code></pre><p>XmlHttpRequest对象解析:<br>　　   它的属性有：<br>  　　  onreadystatechange  每次状态改变所触发事件的事件处理程序。<br>  　　  responseText     从服务器进程返回数据的字符串形式。<br>  　　  responseXML    从服务器进程返回的DOM兼容的文档数据对象。<br>  　　  status           从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）<br>  　　  status Text       伴随状态码的字符串信息<br>  　　  readyState       对象状态值<br>　　　　0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）<br>　　　　1 (初始化) 对象已建立，尚未调用send方法<br>　　　　2 (发送数据) send方法已调用，但是当前的状态及http头未知<br>　　　　3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，<br>　　　　4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据</p><p>定义js对象和属性</p><pre><code>var person = function(){};var p = persopn.prototype;p.name=&apos;张三&apos;;page=18;p.add = function() {    alert(&quot;HELLO&quot;);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是JS中的闭包&quot;&gt;&lt;a href=&quot;#什么是JS中的闭包&quot; class=&quot;headerlink&quot; title=&quot;什么是JS中的闭包&quot;&gt;&lt;/a&gt;什么是JS中的闭包&lt;/h4&gt;&lt;p&gt;闭包就是能够读取其他函数内部变量的函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;functio
      
    
    </summary>
    
    
      <category term="JS" scheme="http://www.zhangsun.site/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat端口配置及原理详解</title>
    <link href="http://www.zhangsun.site/2018/01/30/Tomcat%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.zhangsun.site/2018/01/30/Tomcat端口配置及原理详解/</id>
    <published>2018-01-30T08:56:09.000Z</published>
    <updated>2018-01-30T09:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Tomcat-端口配置，及原理详解"><a href="#Tomcat-端口配置，及原理详解" class="headerlink" title="Tomcat 端口配置，及原理详解"></a>Tomcat 端口配置，及原理详解</h4><p>如果想深入了解tomcat的各个端口及配置，建议通读文章，对初学者十分有利，整理自网络。</p><p>Tomcat服务器需配置三个端口才能启动，安装时默认启用了这三个端口，当要运行多个tomcat服务时需要修改这三个端口，不能相同。端口配置路径为tomcat\ conf\service.xml</p><p>修改Shutdown端口（默认为8005端口）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>修改http访问端口（默认为8080端口）<br>负责建立HTTP连接。在通过浏览器访问Tomcat服务器的Web应用时，使用的就是这个连接器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;&lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt;&lt;!-- &lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>AJP协议访问端口（默认为8009端口）<br>负责和其他的HTTP服务器建立连接。在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure><p>Web客户访问Tomcat服务器上JSP组件的两种方式如图所示。</p><p><img src="Tomcat端口配置及原理详解/1.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Tomcat-端口配置，及原理详解&quot;&gt;&lt;a href=&quot;#Tomcat-端口配置，及原理详解&quot; class=&quot;headerlink&quot; title=&quot;Tomcat 端口配置，及原理详解&quot;&gt;&lt;/a&gt;Tomcat 端口配置，及原理详解&lt;/h4&gt;&lt;p&gt;如果想深入了解tom
      
    
    </summary>
    
    
      <category term="Tomcat" scheme="http://www.zhangsun.site/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat中的三个端口的含义</title>
    <link href="http://www.zhangsun.site/2018/01/30/tomcat%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>http://www.zhangsun.site/2018/01/30/tomcat中的三个端口的含义/</id>
    <published>2018-01-30T08:42:47.000Z</published>
    <updated>2018-01-30T08:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>服务器关闭监听端口：<br><img src="tomcat中的三个端口的含义/1.png" alt=""></p><p> 详解：</p><pre><code> 　　port:指定一个端口，这个端口负责监听关闭Tomcat的请求 　　当执行shutdown.sh的时候会向以上端口发送的关闭服务器的命令字符串</code></pre></li><li><p>服务器请求监听端口：<br><img src="tomcat中的三个端口的含义/2.png" alt=""></p><p> 详解：</p><pre><code> 　　port:服务器连接器的端口号,该连接器将在指定端口侦听来自客户端的请求。 　　redirectPort:服务器正在处理http请求时收到了一个SSL传输请求后重定向的端口号。 　　connectionTimeout:等待超时的时间数（以毫秒为单位）。</code></pre></li><li><p>AJP请求监听端口：<br><img src="tomcat中的三个端口的含义/3.png" alt=""></p><p> 详解：</p><pre><code> 　　AJP协议访问端口（默认为8009端口）  　　负责和其他的HTTP服务器建立连接。在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;服务器关闭监听端口：&lt;br&gt;&lt;img src=&quot;tomcat中的三个端口的含义/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt; 详解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 　　port:指定一个端口，这个端口负责监听关闭Tomcat的请求
 　　当执行shutd
      
    
    </summary>
    
    
      <category term="Tomcat" scheme="http://www.zhangsun.site/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>ifconfig、ifup、ifdown的用法</title>
    <link href="http://www.zhangsun.site/2018/01/30/ifconfig%E3%80%81ifup%E3%80%81ifdown%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://www.zhangsun.site/2018/01/30/ifconfig、ifup、ifdown的用法/</id>
    <published>2018-01-30T08:36:30.000Z</published>
    <updated>2018-01-31T05:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ifconfig</strong></p><pre><code>ifconfig 主要是可以手动的启动、观察与修改网络接口的相关参数，可以修改的参数很多，包括 IP 参数以及 MTU 等等都可以修改.对应的配置文件为/etc/sysconfig/network-scripts/ifcfg-ethxifconfig {interface} {up|down}  &lt;== 观察与启动接口ifconfig interface {options}    &lt;== 设定与修改接口选项与参数：interface：网络卡接口代号，包括 eth0, eth1, ppp0 等等options  ：可以接的参数，包括如下：up, down ：启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)mtu      ：可以设定不同的 MTU 数值，例如 mtu 1500 (单位为 byte)netmask  ：就是子屏蔽网络；broadcast：就是广播地址啊[root@redhat6 ~]# ifconfigeth0      Link encap:Ethernet  HWaddr 08:00:27:4C:C5:88 inet addr:192.168.1.217  Bcast:192.168.1.255  Mask:255.255.255.0inet6 addr: fe80::a00:27ff:fe4c:c588/64 Scope:LinkUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1RX packets:218811 errors:0 dropped:0 overruns:0 frame:0TX packets:85 errors:0 dropped:0 overruns:0 carrier:0collisions:0 txqueuelen:1000RX bytes:14322456 (13.6 MiB)  TX bytes:11859 (11.5 KiB)</code></pre><p>上面出现的各项数据是这样的(数据排列由上而下、由左而右)：</p><pre><code>eth0：就是网络卡的代号，也有 lo 这个 loopback ；HWaddr：就是网络卡的硬件地址，俗称的 MAC 是也；inet addr：IPv4 的 IP 地址，后续的 Bcast, Mask 分别代表的是 Broadcast 与 netmask 喔！inet6 addr：是 IPv6 的版本的 IP ，我们没有使用，所以略过；MTU：就是第二章谈到的 MTU 啊！RX：那一行代表的是网络由启动到目前为止的封包接收情况， packets 代表封包数、errors 代表封包发生错误的数量、 dropped 代表封包由于有问题而遭丢弃的数量等等TX：与 RX 相反，为网络由启动到目前为止的传送情况；collisions：代表封包碰撞的情况，如果发生太多次， 表示你的网络状况不太好；txqueuelen：代表用来传输数据的缓冲区的储存长度；RX bytes, TX bytes：总接收、发送字节总量透过观察上述的资料，大致上可以了解到你的网络情况，尤其是那个RX, TX 内的 error 数量，以及是否发生严重的collision 情况，都是需要注意的喔！临时修改网络参数：ifconfig eth0 192.168.1.217 netmask 255.255.255.0 broadcast 192.168.1.255启动、关闭网卡：ifconfig eth0 up/down查看DNS地址：cat /etc/resolv.conf重启网络服务：/etc/init.d/network restart</code></pre><p> <strong>ifup、ifdown</strong></p><pre><code>ifup   {interface}ifdown {interface}这2个程序主要是搜寻/etc/sysconfig/network-scripts目录下的配置文件 (ifcfg-ethx) 来进行启动与关闭的， 所以在使用前请确定 ifcfg-ethx 是否真的存在于正确的目录内，否则会启动失败喔！ 另外，如果以 ifconfig eth0 .... 来设定或者是修改了网络接口后， 那就无法再以 ifdown eth0 的方式来关闭了！因为 ifdown 会分析比对目前的网络参数与ifcfg-eth0 是否相符，不符的话，就会放弃该次动作。因此，使用 ifconfig 修改完毕后，应该要以 ifconfig eth0 down 才能够关闭该接口喔。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;ifconfig&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ifconfig 主要是可以手动的启动、观察与修改网络接口的相关参数，可以修改的参数很多，包括 IP 参数以及 MTU 等等都可以修改.对应的配置文件为/etc/sysconfig/netwo
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.zhangsun.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>AOP和filter的关系</title>
    <link href="http://www.zhangsun.site/2018/01/30/Aop%E5%92%8Cfilter%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://www.zhangsun.site/2018/01/30/Aop和filter的关系/</id>
    <published>2018-01-30T08:26:04.000Z</published>
    <updated>2018-01-30T08:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>AOP</strong>（Aspect-Oriented Programming，面向切面编程）是一种编程思想，并不是一种具体的实现，谈到实现一般有Filter和代理模式两种常见的使用方式。</p><p>Spring中的AOP也是封装代理模式完成的，可以说是<strong>OOP</strong>（Object-Oriented Programing，面向对象编程）的补充和完善。OOP利用封装、继承和多态把一切事物打造成对象结构，但是对于所有对象中都存在的一些公共行为，OOP就显得无能为力，也就是说OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。抽象和接口虽好，但对所有不相干的对象建立共同的接口或父类未免有些生硬，例如日志功能，日志代码几乎散布在所有的对象层次中，而它和散布到对象的核心功能毫无关系，对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。因此，为减少这种大量的重复代码，面向切面技术诞生了，AOP和OOP的关系好似JSP和Servlet的关系，以此之长，补彼之短。</p><p><img src="Aop和filter的关系/142.png" alt="Aop and Filter"></p><p><strong>Java</strong>中常见的AOP技术有两个，分别是Filter和代理模式（也可以称为过滤器和拦截器），Filter是基于回调函数，代理模式是基于Java反射技术，代理模式又分为静态代理和动态代理，动态代理就是拦截器的简单实现。他们各自实现的功能不同，原理如出一辙。如上图，以添加用户为例，采用Module1架构模式，从图中可以看出无论程序从左向右或者从右向左执行都必须经过Filter，Filter在Request到达JSP（Servlet）前截获Request并进行预处理，也可以在Response离开JSP（Servlet）时处理Response，然后对Request进行统一的设置后继续向后传递，比如可以在Filter完成字符集的设置，用户身份的识别，敏感词汇的过滤等等，配置Filter个数不限。</p><p><strong>Filter</strong>是职责链模式的经典应用，从上面示例代码可以看出，实现了Filter接口的doFilter方法主要用于截获Request对象，把截获的请求处理后（设置字符集），调用FilterChain 接口的chain.doFilter(request,response)方法，把处理权传递给下一个filter。</p><p>其中，FilterChain维护了一个链表，链表中存放着配置对象的链条，每次用户调用 一次chain.doFilter(request, response)，链表就去取下一个配置对象，再通过配置对象 得到下一个filter，然后调用该filter，接着在filter里写的逻辑就被执行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;AOP&lt;/strong&gt;（Aspect-Oriented Programming，面向切面编程）是一种编程思想，并不是一种具体的实现，谈到实现一般有Filter和代理模式两种常见的使用方式。&lt;/p&gt;
&lt;p&gt;Spring中的AOP也是封装代理模式完成的，可以说
      
    
    </summary>
    
    
      <category term="AOP" scheme="http://www.zhangsun.site/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>利用JDK和spring-task实现高可用定时任务</title>
    <link href="http://www.zhangsun.site/2018/01/18/%E5%88%A9%E7%94%A8JDK%E5%92%8Cspring-task%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://www.zhangsun.site/2018/01/18/利用JDK和spring-task实现高可用定时任务/</id>
    <published>2018-01-18T03:11:59.000Z</published>
    <updated>2018-01-19T13:20:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-定时任务框架简介："><a href="#1-定时任务框架简介：" class="headerlink" title="1. 定时任务框架简介："></a>1. 定时任务框架简介：</h3><p>当前定时任务的实现方式主要有： 采用Quartz、Spring-Task、JDK、Zookeeper、Reids、Elastic-Job等。本文只介绍Spring-Task和JDK定时任务的使用。 主要是因为对于Java开发来说，这两个定时任务是不需要引入任何外部Jar包的，属于轻量级定时任务框架。当然，该文适合简单的定时任务，对于复杂的定时任务可采用定时任务调度服务器的方式进行实现。本文将以SpringBoot为框架，以动态维护活动开始和结束时间为例，介绍Spring-Task和JDK定时任务的实现。</p><h3 id="2-Spring-Task的使用："><a href="#2-Spring-Task的使用：" class="headerlink" title="2. Spring-Task的使用："></a>2. Spring-Task的使用：</h3><ul><li>App.java类中添加如下注解：</li></ul><pre><code>@EnableAsync  @SpringBootApplication  @ComponentScan  @EnableAutoConfiguration  @EnableScheduling  public class App extends SpringBootServletInitializer {      public static void main(String[] args) {          SpringApplication.run(App.class, args);      }  }  </code></pre><ul><li>编写任务类ActivityTask.java</li></ul><pre><code>package com.bldz.promotion.task;  import com.bldz.promotion.common.Constants;  import com.bldz.promotion.service.ActivityService;  import org.slf4j.Logger;  import org.slf4j.LoggerFactory;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.scheduling.annotation.Scheduled;  import org.springframework.stereotype.Component;  /** * 更新活动时间   * * @author ZhangsunJiankun 2018年1月11日18:06:05   */@Component  public class ActivityTask {      private final ActivityService activityService;      private static Logger logger = LoggerFactory.getLogger  (ActivityTask.class);      @Autowired      public ActivityTask(ActivityService activityService) {          this.activityService = activityService;      }      /**     * 更新活动开始时间       */    @Scheduled(cron = &quot;0 0/5 * * * ?&quot;)      public void updateToHaving() {          this.update(Constants.ACTIVITY_STATUS_HAVING);      }      /**     * 更新活动时间为已结束       */    @Scheduled(cron = &quot;0 0/5 * * * ?&quot;)      public void updateToEnd() {          this.update(Constants.ACTIVITY_STATUS_OVER);      }      private void update(String status) {          if(Constants.ACTIVITY_STATUS_HAVING.equals(status)) {              int items = activityService.updateStatusToHaving();              if(items &gt; 0) {                  logger.info(&quot;update activity status to having successfully!   Number of updates:{} &quot;, items);              }          } else if(Constants.ACTIVITY_STATUS_OVER.equals(status)){              int items = activityService.updateStatusToEnd();              if(items &gt; 0) {                  logger.info(&quot;update activity status to end successfully!   Number of updates:{} &quot;, items);              }          } else {              logger.error(&quot;update status error! status:{}&quot;, status);          }      }  }  </code></pre><h6 id="至此Spring-Task定时任务已经完成，是不是很简单-）-难点主要在于-Schedule注解的使用，接下来我就说说这个注解中的参数含义，及使用。"><a href="#至此Spring-Task定时任务已经完成，是不是很简单-）-难点主要在于-Schedule注解的使用，接下来我就说说这个注解中的参数含义，及使用。" class="headerlink" title="至此Spring-Task定时任务已经完成，是不是很简单:） 难点主要在于@Schedule注解的使用，接下来我就说说这个注解中的参数含义，及使用。"></a>至此Spring-Task定时任务已经完成，是不是很简单:） 难点主要在于@Schedule注解的使用，接下来我就说说这个注解中的参数含义，及使用。</h6><pre><code>@Schedule(String corn, Long fixedDelay, Long fixedRate, Long initialDelay, Long zone)corn: 定时任务表达式fixedDelay: 以固定的频率，在最后一次调用的完成之后到下一此调用开始之间执行该方法 (以毫秒为单位)。initialDelay: Spring容器启动之后第一次开始执行该Job的推迟时间fixedRate: 以固定的频率执行该方法zone: 服务器所在的时区</code></pre><h6 id="corn表达式的使用"><a href="#corn表达式的使用" class="headerlink" title="corn表达式的使用"></a>corn表达式的使用</h6><pre><code>Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域（Spring-Task只支持6个域），每一个域代表一个含义，每一个域可出现的字符如下： Seconds:可出现&quot;, - * /&quot;四个字符，有效范围为0-59的整数 Minutes:可出现&quot;, - * /&quot;四个字符，有效范围为0-59的整数 Hours:可出现&quot;, - * /&quot;四个字符，有效范围为0-23的整数 DayofMonth:可出现&quot;, - * / ? L W C&quot;八个字符，有效范围为0-31的整数 Month:可出现&quot;, - * /&quot;四个字符，有效范围为1-12的整数或JAN-DEc DayofWeek:可出现&quot;, - * / ? L C #&quot;四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一， 依次类推 Year:可出现&quot;, - * /&quot;四个字符，有效范围为1970-2099年每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是： (1)*：表示匹配该域的任意值，假如在Minutes域使用*, 即表示每分钟都会触发事件。(2)?:只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。 (3)-:表示范围，例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 (4)/：表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. (5),:表示列出枚举值值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 (6)L:表示最后，只能出现在DayofWeek和DayofMonth域，如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 (7)W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 (8)LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 (9)#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。举几个例子: 0 0 2 1 * ? * 表示在每月的1日的凌晨2点调度任务 0 15 10 ? * MON-FRI 表示周一到周五每天上午10：15执行作业 0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 0 0 12 ? * WED 表示每个星期三中午12点 &quot;0 0 12 * * ?&quot; 每天中午12点触发 &quot;0 15 10 ? * *&quot; 每天上午10:15触发 &quot;0 15 10 * * ?&quot; 每天上午10:15触发 &quot;0 15 10 * * ? *&quot; 每天上午10:15触发 &quot;0 15 10 * * ? 2005&quot; 2005年的每天上午10:15触发 &quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发 &quot;0 0/5 14 * * ?&quot; 在每天下午2点到下午2:55期间的每5分钟触发 &quot;0 0/5 14,18 * * ?&quot; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 &quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发 &quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午2:10和2:44触发 &quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午10:15触发 &quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发 &quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发 &quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发 &quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月的最后一个星期五上午10:15触发 &quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发</code></pre><h3 id="3-JDK定时时任务的实现："><a href="#3-JDK定时时任务的实现：" class="headerlink" title="3. JDK定时时任务的实现："></a>3. JDK定时时任务的实现：</h3><ul><li>编写TaskUtil.java</li></ul><pre><code>package com.bldz.promotion.common.utils;import com.google.common.util.concurrent.ThreadFactoryBuilder;import org.apache.commons.lang3.concurrent.BasicThreadFactory;import java.util.concurrent.*;/** * Description: 基于JDK的定时任务工具类 * * @author Jiankun.Zhangsun 2018/1/11 17:20 */public class TaskUtils {    private static ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;demo-pool-%d&quot;).build();    public static void schedule(Runnable task, Long delayed, TimeUnit timeUnit) {        ScheduledExecutorService scheduleService = Executors.newScheduledThreadPool(5, threadFactory);        scheduleService.schedule(task, delayed, timeUnit);        scheduleService.shutdown();    }}</code></pre><ul><li>编写StatusTask.java</li></ul><pre><code>package com.bldz.promotion.task;import com.bldz.promotion.exceptions.PromotionException;import com.bldz.promotion.service.ActivityService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * Description: * * @author Jiankun.Zhangsun 2018/1/16 15:43 */public class StatusTask implements Runnable {    private Logger logger = LoggerFactory.getLogger(StatusTask.class);    private ActivityService activityService;    private String status;    private String key;    public StatusTask(String status, String key, ActivityService activityService) {        this.status = status;        this.key = key;        this.activityService = activityService;    }    @Override    public void run() {        int update;        // 新线程中的异常不会在main线程中抛出来        try {            update = activityService.updateActivityStatus(key, status);        } catch (PromotionException e) {            logger.error(&quot;update activity status to &quot; + status + &quot; failed!! failed reason:{}&quot;, e) ;            return;        }        if(update &gt; 0) {            logger.info(&quot;update activity status to &quot; + status + &quot; successfully!!&quot;);        } else {            logger.error(&quot;update activity status to &quot; + status + &quot; failed!! update key:{} failed reason:{}&quot;, key, &quot;database error!&quot;) ;        }    }}</code></pre><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>Spring-Task和JDK都是JavaEE开发中常用到的，不需要额外引入，相对轻量级。 两者分别存在以下优缺点：</p><ol><li>@Schedule中所有参数都是常量，不支持变量，必须在容器启动的时候就开始执行；</li><li>JDK中的定时任务，是通过重启一个线程去执行定时任务的，这个线程根据需求随时可以启动，其中的delay参数支持变量的方式；</li><li>JDK中的定时任务如果宕机了，或者服务器重启了会停止执行，所以采用Spring-Task每5分钟执行一次进行保证定时任务的高可用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-定时任务框架简介：&quot;&gt;&lt;a href=&quot;#1-定时任务框架简介：&quot; class=&quot;headerlink&quot; title=&quot;1. 定时任务框架简介：&quot;&gt;&lt;/a&gt;1. 定时任务框架简介：&lt;/h3&gt;&lt;p&gt;当前定时任务的实现方式主要有： 采用Quartz、Spring-
      
    
    </summary>
    
    
      <category term="Schedule" scheme="http://www.zhangsun.site/tags/Schedule/"/>
    
  </entry>
  
  <entry>
    <title>springboot集成swagger注解入门</title>
    <link href="http://www.zhangsun.site/2018/01/03/springboot%E9%9B%86%E6%88%90swagger%E6%B3%A8%E8%A7%A3%E5%85%A5%E9%97%A8/"/>
    <id>http://www.zhangsun.site/2018/01/03/springboot集成swagger注解入门/</id>
    <published>2018-01-03T06:46:49.000Z</published>
    <updated>2018-01-04T08:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Swagger简介-THE-WORLD’S-MOST-POPULAR-API-TOOLING"><a href="#Swagger简介-THE-WORLD’S-MOST-POPULAR-API-TOOLING" class="headerlink" title="Swagger简介 THE WORLD’S MOST POPULAR API TOOLING"></a><a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a>简介 THE WORLD’S MOST POPULAR API TOOLING</h4><p>Swagger is the world’s largest framework of API developer tools for the OpenAPI Specification(OAS), enabling development across the entire API lifecycle, from design and documentation, to test and deployment.</p><h4 id="Swagger的作用"><a href="#Swagger的作用" class="headerlink" title="Swagger的作用:"></a>Swagger的作用:</h4><p>Swagger是一款RESTFUL接口的文档在线自动生成框架，该框架可以自动生成接口文档，也可以进行接口测试，生成mock数据等。通过使用该框架可以快速、动态的更新和管理API，方便前、后台协同开发，提高开发效率，减少开发过程中一些人为的误差。    Swagger让部署管理和使用功能强大的API从未如此简单。</p><h4 id="SpringBoot-集成Swagger步骤"><a href="#SpringBoot-集成Swagger步骤" class="headerlink" title="SpringBoot 集成Swagger步骤:"></a>SpringBoot 集成Swagger步骤:</h4><ol><li><p>引入maven坐标配置</p></li><li><p>建立Swagger配置</p></li><li><p>使用Swagger注解</p></li><li><p>访问API文档查看效果</p></li></ol><p><strong>引入maven坐标：</strong></p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt;${springfox-version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;${springfox-version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;joda-time&lt;/groupId&gt;    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;    &lt;version&gt;2.9.9&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong> 建立Swagger配置类： </strong></p><pre><code>package com.example.swagger.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * Description: swagger配置类，通过Configuration注解让spring容器自动加载该类 * * @author Jiankun.Zhangsun 2018/1/2 15:13 */@Configuration@EnableSwagger2public class SwaggerConfig {    /**     * 将返回值当作一个bean注入到容器中     *     * @return api文档对象     */    @Bean    public Docket createRestApi() {        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo()).useDefaultResponseMessages(false)                .select()                .paths(PathSelectors.any())                .build();    }    /**     * api 文档信息对象，主要是文档标题相关的信息     *     * @return 文档信息对象     */    private ApiInfo apiInfo() {        return new ApiInfoBuilder()                .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;)                .description(&quot;更多Spring Boot相关文章请关注：http://blog.didispace.com/&quot;)                .termsOfServiceUrl(&quot;http://blog.didispace.com/&quot;)                .contact(&quot;Murphy&apos;s BLOG&quot;)                .version(&quot;1.0.0.0&quot;)                .build();    }}</code></pre><p>代码解释：<br>ApiInfo 这个对象是用来生成文档相关信息的，通过这个对象可以构建出文档标题、描述、版本等信息；<br>createRestApi() 这个方法是进行Docket创建的；<br>Docket 这个对象是用来渲染整个API文档的对象，这个对象通过@Bean注解注册到了Spring容器中，Swagger会自动加载该对象进行文档构建。</p><p><strong> 使用Swagger注解： </strong></p><pre><code>package com.example.swagger.controller;import io.swagger.annotations.*;import org.springframework.web.bind.annotation.*;/** * Description: swagger controller test * * @author Jiankun.Zhangsun 2018/1/2 15:40 */@Api(value = &quot;petApi&quot;, description = &quot;pet api description&quot;)@RestControllerpublic class PetApi {    @ApiOperation(value = &quot;get city by state&quot;, notes = &quot;Get city by state&quot;,             responseContainer = &quot;container&quot;,            httpMethod = &quot;get&quot;,            code = 304,             hidden = false,             produces = &quot;application/json;charset=utf-8&quot;,            response = Pet.class,             tags = {&quot;user&quot;, &quot;person&quot;, &quot;pet&quot;})    @ApiResponses(value = {@ApiResponse(code = 405, message = &quot;Invalid input&quot;, response = Pet.class) })    @RequestMapping(value = &quot;/pet&quot;, method = RequestMethod.GET)    public Pet getPet(@ApiParam(value = &quot;param introduction&quot;, name = &quot;name&quot;, required = true) @RequestBody Pet p) {        Pet pet = new Pet();        pet.setName(p.getName());        pet.setAge(p.getAge());        return pet;    }}</code></pre><p>代码解释：<br>@Api(value, description)</p><pre><code>类级别的注解，用于标识这是一个Api文档类，value： 表示Api文档名称，description： 用于简单的描述该Api文档。</code></pre><p>@ApiOperation(value，notes，response，tags，hidden，httpMethod，consumer…)， </p><pre><code>value：api功能描述， notes: api功能的详细描述 response: 返回值类型的定义，class类型tags: api分类的管理，是一个字符串数组对象，每个值对应一个标签目录，没有就会新建一个，有了就直接进行分类hidden: 是否隐藏该Api，默认为false， httpMethod: 请求方式consumer: 接收的请求头信息produces： 生产的请求头信息</code></pre><p>@ApiParam(value, name, required)</p><pre><code>value: 参数说明name: 参数名称required: 是否必传</code></pre><p><strong> 访问API文档查看效果： </strong></p><p>本地访问路径：<a href="http://localhost:8081/swagger-ui.html#/" target="_blank" rel="noopener">http://localhost:8081/swagger-ui.html#/</a> 即可查看生成的效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Swagger简介-THE-WORLD’S-MOST-POPULAR-API-TOOLING&quot;&gt;&lt;a href=&quot;#Swagger简介-THE-WORLD’S-MOST-POPULAR-API-TOOLING&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="Swagger" scheme="http://www.zhangsun.site/tags/Swagger/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis常用注解整理</title>
    <link href="http://www.zhangsun.site/2018/01/02/Mybatis%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%95%B4%E7%90%86/"/>
    <id>http://www.zhangsun.site/2018/01/02/Mybatis常用注解整理/</id>
    <published>2018-01-02T01:11:49.000Z</published>
    <updated>2018-01-02T09:18:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>@RequestBody: 要求请求体是json格式<br>@RequestMapping(value: 请求路径, method: 请求方法类型, produces: 接收的数据类型，对应的是content-type头信息): 请求路径映射<br>@ResponseBody: 返回值转换成json格式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@RequestBody: 要求请求体是json格式&lt;br&gt;@RequestMapping(value: 请求路径, method: 请求方法类型, produces: 接收的数据类型，对应的是content-type头信息): 请求路径映射&lt;br&gt;@ResponseBod
      
    
    </summary>
    
    
      <category term="JavaEE" scheme="http://www.zhangsun.site/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>Nginx简介</title>
    <link href="http://www.zhangsun.site/2017/12/31/Nginx%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.zhangsun.site/2017/12/31/Nginx简介/</id>
    <published>2017-12-31T08:28:06.000Z</published>
    <updated>2018-01-31T08:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p><strong>http服务器</strong>：Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。<br><strong>虚拟主机</strong>：可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。<br><strong>反向代理、负载均衡</strong>：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h4&gt;&lt;p&gt;Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Ig
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://www.zhangsun.site/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin基础语法</title>
    <link href="http://www.zhangsun.site/2017/12/31/Kotlin%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.zhangsun.site/2017/12/31/Kotlin基础语法/</id>
    <published>2017-12-31T05:39:32.000Z</published>
    <updated>2018-01-31T06:08:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：</strong><br>&emsp;&emsp;上海百联大宗内部员工培训系统是为了给内部员工提供一个高素质培训平台，也是百联研发部新技术实验平台。该系统前期采用的是Vertx作为系统框架，以Kotlin作为开发语言，以Vue作为前台框架。将来还会有更多的新技术应用于该平台。作为平台的开发人员，为了满足开发的需求，所以学习了Kotlin, 现将基本语法整理出来供大家学习，同时也便于日后查看。</p><h4 id="空类型用法："><a href="#空类型用法：" class="headerlink" title="空类型用法："></a>空类型用法：</h4><p><img src="Kotlin基础语法/1.png" alt="Kotlin"><br>as : 类型转换关键字/包别名<br>安全类型转换:<br>智能类型转换: </p><h4 id="区间"><a href="#区间" class="headerlink" title="区间:"></a>区间:</h4><p><img src="Kotlin基础语法/2.png" alt="Kotlin"></p><h4 id="数组的使用方法"><a href="#数组的使用方法" class="headerlink" title="数组的使用方法"></a>数组的使用方法</h4><p><img src="Kotlin基础语法/3.png" alt="Kotlin"></p><h4 id="基本数据类型的数组"><a href="#基本数据类型的数组" class="headerlink" title="基本数据类型的数组"></a>基本数据类型的数组</h4><p><img src="Kotlin基础语法/4.png" alt="Kotlin"></p><h4 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h4><p><img src="Kotlin基础语法/5.png" alt="Kotlin"></p><h4 id="Lamd表达式"><a href="#Lamd表达式" class="headerlink" title="Lamd表达式"></a>Lamd表达式</h4><p><img src="Kotlin基础语法/6.png" alt="Kotlin"></p><h4 id="Lamd表达式参数传递"><a href="#Lamd表达式参数传递" class="headerlink" title="Lamd表达式参数传递"></a>Lamd表达式参数传递</h4><p><img src="Kotlin基础语法/7.png" alt="Kotlin"></p><h4 id="成员变量和局部变量的定义和区别："><a href="#成员变量和局部变量的定义和区别：" class="headerlink" title="成员变量和局部变量的定义和区别："></a>成员变量和局部变量的定义和区别：</h4><p>成员变量都是用val或var修饰的，而没有被这两个关键字修饰的变量都是局部变量<br><img src="Kotlin基础语法/8.png" alt="Kotlin"></p><h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><p><img src="Kotlin基础语法/9.png" alt="Kotlin"></p><h4 id="成员变量的访问控制"><a href="#成员变量的访问控制" class="headerlink" title="成员变量的访问控制"></a>成员变量的访问控制</h4><p><img src="Kotlin基础语法/10.png" alt="Kotlin"></p><h4 id="运算符的定义"><a href="#运算符的定义" class="headerlink" title="运算符的定义"></a>运算符的定义</h4><p><img src="Kotlin基础语法/11.png" alt="Kotlin"></p><h4 id="Kotlin关键字："><a href="#Kotlin关键字：" class="headerlink" title="Kotlin关键字："></a>Kotlin关键字：</h4><p><strong>operator:</strong>定义运算符<br><strong>infix:</strong>定义中缀表达式<br><strong>override:</strong>重写父类方法<br><strong>constructor:</strong>构造器<br><strong>const:</strong>定义编译期常量<br><strong>val:</strong>定义普通成员常量<br><strong>var:</strong>定义成员变量</p><p><strong>注意：</strong></p><ol><li><p>在Kotlin中when，if语句和Lamda表达式一样具有返回值，返回值为最后一行的值</p></li><li><p>在Kotlin中默认的类和方法都是final的，要继承重写必须用关键字open，或者设置成abstract类型，重写方法必须使用override关键字</p></li></ol><h4 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h4><p><img src="Kotlin基础语法/12.png" alt="Kotlin"></p><h4 id="when、continue-和-break"><a href="#when、continue-和-break" class="headerlink" title="when、continue 和 break"></a>when、continue 和 break</h4><p>when表达式，Java中switch的替代品, 循环关键字continue和break<br><img src="Kotlin基础语法/13.png" alt="Kotlin"></p><h4 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h4><p><img src="Kotlin基础语法/14.png" alt="Kotlin"></p><h4 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h4><p><img src="Kotlin基础语法/15.png" alt="Kotlin"></p><h4 id="Sperat-Operator"><a href="#Sperat-Operator" class="headerlink" title="Sperat Operator"></a>Sperat Operator</h4><p><img src="Kotlin基础语法/16.png" alt="Kotlin"></p><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p><img src="Kotlin基础语法/17.png" alt="Kotlin"></p><h4 id="继承和实现"><a href="#继承和实现" class="headerlink" title="继承和实现"></a>继承和实现</h4><p><img src="Kotlin基础语法/18.png" alt="Kotlin"><br><img src="Kotlin基础语法/19.png" alt="Kotlin"><br><img src="Kotlin基础语法/20.png" alt="Kotlin"><br><img src="Kotlin基础语法/21.png" alt="Kotlin"></p><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p><img src="Kotlin基础语法/22.png" alt="Kotlin"></p><h4 id="静态方法的定义"><a href="#静态方法的定义" class="headerlink" title="静态方法的定义"></a>静态方法的定义</h4><p><img src="Kotlin基础语法/23.png" alt="Kotlin"><br><img src="Kotlin基础语法/24.png" alt="Kotlin"></p><p><strong>方法签名：</strong>这是一个JVM概念，虚拟机根据方法签名来判断方法的唯一性，从而会存在方法的重载。方法返回值不属于方法签名</p><p>lamd表达式是一种匿名函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;上海百联大宗内部员工培训系统是为了给内部员工提供一个高素质培训平台，也是百联研发部新技术实验平台。该系统前期采用的是Vertx作为系统框架，以Kotlin作为开发语言，以Vue作为前台框架。将来还会有更
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://www.zhangsun.site/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>MySql触发器</title>
    <link href="http://www.zhangsun.site/2017/12/30/MySql%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://www.zhangsun.site/2017/12/30/MySql触发器/</id>
    <published>2017-12-30T06:12:04.000Z</published>
    <updated>2018-02-09T08:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="什么是触发器"><a href="#什么是触发器" class="headerlink" title="什么是触发器"></a>什么是触发器</h4><p>触发器，顾名思义是在触发了某个动作之后而执行的一串数据库脚本。主要是用在数据的增、删、改动作之上。触发器的执行是自动的，只要触发器中监听的动作发生了触发器就会自动执行。</p><h4 id="触发器的定义"><a href="#触发器的定义" class="headerlink" title="触发器的定义"></a>触发器的定义</h4><pre><code>DROP TRIGGER IF EXISTS triggerName; -- just for update triggerCREATE TRIGGER triggerName BEFORE UPDATE  ON tableName FOR EACH ROW  BEGIN       -- to do something  END;</code></pre><h4 id="触发器中的BEFORE-和-AFTER"><a href="#触发器中的BEFORE-和-AFTER" class="headerlink" title="触发器中的BEFORE 和 AFTER"></a>触发器中的BEFORE 和 AFTER</h4><p>BEFORE：(INSERT、UPDATE)可以对NEW中的数据进行拦截<strong>修改</strong>，<br>AFTER：不能对NEW进行修改。<br>两者都不能修改OLD（<strong>只读</strong>）数据，但是可以获取到OLD中的数据。即，触发器不能修改原来表中的数据。</p><pre><code>DELIMITER $$DROP TRIGGER IF EXISTS updateTrigger;CREATE TRIGGER updateTrigger BEFORE UPDATE ON user FOR EACH ROW    BEGIN    DECLARE oldName VARCHAR(20);    DECLARE newName VARCHAR(20);    -- 测试更新操作之前能否对拿到OLD和NEW的虚拟表对象    SET newName = NEW.name;    SET oldName = OLD.name;    IF newName IS NOT NULL AND oldName IS NOT NULL THEN        SET NEW .name = &quot;error name&quot;;    END IF;    END $$DELIMITER ;-- 验证UPDATE user SET name = &quot;zhangsan&quot; WHERE id = 4;-- 查看结果SELECT * FROM user WHERE id = 4;</code></pre><p><img src="imgs/20180209-161422.png" alt=""></p><p><strong>实例：</strong></p><pre><code>-- 对user表中插入前的数据进行拦截修改用户名为大写DELIMITER $$DROP TRIGGER IF EXISTS nameToUpperCase;CREATE TRIGGER nameToUpperCase BEFORE INSERT ON user FOR EACH ROW    BEGIN    DECLARE upperName VARCHAR(20);    /*    对于insert 操作，只能修改插入的数据，而不能对数据库中原来的数据进行修改。    即：只能操作NEW对象，不能操作OLD对象    */    SET upperName = NEW.name;    SELECT upper(upperName) INTO upperName;    SET NEW.name = upperName;    END $$DELIMITER ;-- 向表中插入数据INSERT INTO user (name, age, gender, creator, create_time) VALUES (&quot;lowwer&quot;, 22, &quot;boy&quot;, 1, sysdate());-- 查询结果SELECT * FROM user WHERE age = 22;</code></pre><p><strong>总结：</strong><br>AFTER：是在记录操纵之后触发，是先完成数据的增删改，再触发，触发的语句晚于监视的增删改操作，无法影响前面的增删改动作<br>BEFORE：是在记录操纵之前触发，是先完成触发，再增删改，触发的语句先于监视的增删改，我们就有机会判断，修改即将发生的操作，如：我们在触发之前需要判断new值和old值的大小或关系，如果满足要求就触发，不通过就修改再触发；如：表之间定义的有外键，在删除主键时，必须要先删除外键表，这时就有先后之分，这里before相当于设置了断点，我们可以处理删除外键。</p><h4 id="触发器中的NEW-和-OLD"><a href="#触发器中的NEW-和-OLD" class="headerlink" title="触发器中的NEW 和 OLD"></a>触发器中的NEW 和 OLD</h4><ul><li>INSERT语句, 只有NEW是合法的，因为是新添加数据；</li><li>DELETE语句，只有OLD才合法，因为没有新数据可以操作；</li><li><p>UPDATE语句，NEW、OLD可以同时使用。</p><pre><code>DELIMITER $$DROP TRIGGER IF EXISTS deleteTrigger;CREATE TRIGGER deleteTrigger AFTER DELETE ON user FOR EACH ROW    BEGIN    /*    DELETE 触发器在 DELETE 语句执行之前或之后执行。需要知道以下两点：    1.在 DELETE 触发器代码内，你可以引用一个名为 OLD 的虚拟表，访问被删除的行；    2.OLD 中的值全都是只读的，不能更新。下面的例子演示使用 OLD 保存将要被删除的行到一个存档表中：    */    IF OLD.id = 2 THEN        -- 触发器不能在监控增删改的时候再更改同一张表        INSERT INTO course(name, teacher, type) VALUES (&quot;自然&quot;, &quot;王小英&quot;, 1);    END IF;    END $$DELIMITER ;DELETE FROM user WHERE id = 2;</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;什么是触发器&quot;&gt;&lt;a href=&quot;#什么是触发器&quot; class=&quot;headerlink&quot; title=&quot;什么是触发器&quot;&gt;&lt;/a&gt;什么是触发器&lt;/h4&gt;&lt;p&gt;触发器，顾名思义是在触发了某个动作之后而执行的一串数据库脚本。主要是用在数据的增、
      
    
    </summary>
    
    
      <category term="MySql" scheme="http://www.zhangsun.site/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>DOS批处理入门</title>
    <link href="http://www.zhangsun.site/2017/12/29/DOS%E6%89%B9%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8/"/>
    <id>http://www.zhangsun.site/2017/12/29/DOS批处理入门/</id>
    <published>2017-12-29T07:42:51.000Z</published>
    <updated>2017-12-29T17:23:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h3><pre><code>echo hello: 向控制台输出helloecho hello &gt; file.txt: 将hello输出到文件file.txt中echo world &gt;&gt; file.txt: 将world追加到文件file.txt中</code></pre><h3 id="md命令"><a href="#md命令" class="headerlink" title="md命令"></a>md命令</h3><pre><code>md file1, file2, file3 ... 在当前路径下创建多个文件夹</code></pre><h3 id="dir命令"><a href="#dir命令" class="headerlink" title="dir命令"></a>dir命令</h3><pre><code>dir /b: 显示当前路径下所有文件及文件夹名dir /s: 显示当前路径下的所有文件及子文件</code></pre><h3 id="gt-和-gt-gt"><a href="#gt-和-gt-gt" class="headerlink" title="&gt; 和 &gt;&gt;"></a>&gt; 和 &gt;&gt;</h3><pre><code>echo hello &gt; file1.txt: 将hello写入到文件中并覆盖原来的内容echo world &gt;&gt; file.txt: 将world追加到文件file.txt中</code></pre><h3 id="type命令"><a href="#type命令" class="headerlink" title="type命令"></a>type命令</h3><pre><code>filename.ext: 查下看文件中的内容</code></pre><h3 id="通配符-和"><a href="#通配符-和" class="headerlink" title="通配符 * 和 ?"></a><a href="https://baike.baidu.com/item/%E9%80%9A%E9%85%8D%E7%AC%A6/92991?fr=aladdin" target="_blank" rel="noopener">通配符</a> * 和 ?</h3><pre><code>*: 匹配所有的内容?: 仅代表单个字dir /b /s &gt; file.txt: 将文件及文件夹的名称信息输出到file文件中</code></pre><h3 id="ren-rename命令"><a href="#ren-rename命令" class="headerlink" title="ren = rename命令"></a>ren = rename命令</h3><pre><code>ren old.txt new.txt： 重命名文件</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;echo命令&quot;&gt;&lt;a href=&quot;#echo命令&quot; class=&quot;headerlink&quot; title=&quot;echo命令&quot;&gt;&lt;/a&gt;echo命令&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;echo hello: 向控制台输出hello
echo hello &amp;gt; file.t
      
    
    </summary>
    
    
      <category term="WINDOWS" scheme="http://www.zhangsun.site/tags/WINDOWS/"/>
    
  </entry>
  
  <entry>
    <title>方法的重载和重写</title>
    <link href="http://www.zhangsun.site/2017/12/29/%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99/"/>
    <id>http://www.zhangsun.site/2017/12/29/方法的重载和重写/</id>
    <published>2017-12-29T06:41:53.000Z</published>
    <updated>2017-12-29T15:28:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>方法的重载:</strong><overload></overload></p><pre><code>方法的重载是发生在同一个类中,方法名相同,参数列表不同,与返回值类型无关</code></pre><p><strong>方法的重写:</strong><overwrite></overwrite></p><pre><code>方法的重写是发生在具有子父类关系的类中,子类具有与父类定义一样的方法,只是实现不一样    </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;方法的重载:&lt;/strong&gt;&lt;overload&gt;&lt;/overload&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;方法的重载是发生在同一个类中,方法名相同,参数列表不同,与返回值类型无关
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;方法的重写:&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="http://www.zhangsun.site/tags/JavaSE/"/>
    
  </entry>
  
</feed>
